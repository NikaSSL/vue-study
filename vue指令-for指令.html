<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
<title>vue指令-for指令</title>
<meta name="description" content="">
<meta name="keywords" content="">
<link href="" rel="stylesheet">
<script src="vue.js"></script>
</head>
<body>

<!-- 
	* v-for

		* 用于模板渲染的指令
		* 当 Vue.js 用 v-for 正在更新已渲染过的元素列表时，它默认用 “就地复用” 策略。如果数据项的顺序被改变，Vue将不是移动 DOM 元素来匹配数据项的顺序， 而是简单复用此处每个元素，并且确保它在特定索引下显示已被渲染过的每个元素。
		* 参数顺序变化——当包含参数index或key时，对象参数修改为（item，index）或（value，key）
		* v-bind：key——属性track-by被v-bind：key替代
		* n in 10——n由原来的0-9迭代变为1-10迭代
		* track-by:替换为key,用于跟踪每个节点的身份，从而重用和重新排序现有元素。避免vue.js默认的“就地复用”策略，不然删除选中了的第一个数据项，第二个数据项上来后会显示为选中状态
 -->
<div id="app">
	<ul>
		<!-- <li v-for="item in items"> -->
		<li v-for="(item,index) in items">
			<h3>{{item.title}}-{{index}}</h3>
			<p>{{item.description}}</p>
		</li>
	</ul>
	<ul>
		<li v-for="n in 10">{{n}}</li>
	</ul>
	<!-- <ul v-for="item in items" track-by="title"> -->
	<ul v-for="(item,index) in items" :key="item.title">
	<!-- <ul v-for="(item,index) in items"> -->
		<p>
			{{item.title}}
			<input type="checkbox">
			<span @click="deleteItem(index)">X</span>
		</p>
	</ul>
</div>

<script type="text/javascript">
	var vm = new Vue({
		el:'#app',
		data:{
			items:[
			{title:'1',description:'description-1'},
			{title:'2',description:'description-2'},
			{title:'3',description:'description-3'},
			{title:'4',description:'description-4'},
			]
		},
		methods:{
			deleteItem:function(index){
				this.items.splice(index,1);
			}
		}
	})
</script>
</body>
</html>